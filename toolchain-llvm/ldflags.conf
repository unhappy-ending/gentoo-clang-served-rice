# Link time flags. Flags such as -no-pie, -fuse-ld=* and so on are compiler
# flags used during the link phase. Flags starting with -Wl, are direct calls
# to the linker used during link-time.

# -no-pie
#
#  This flag disables position-independent execution. PIE is similar to PIC,
#  but the generated position-independent code can be only linked into
#  executables.
#
#  Some packages might want to compile with -fpie/-fPIE/-pie which makes
#  attacks a little harder, but causes a performance overhead. -no-pie disables
#  the -fPIE, -fpie, -pie, and -static-pie flags.
#
LDFLAGS="-no-pie"

# -Wl,-Bsymbolic
# -Wl,-Bsymbolic-functions
#
# This flag makes the linker bind default visibility defined symbols (or
# functions) locally for shared code. Use -Wl,-Bsymbolic-functions when this
# flag causes issues.
#
LDFLAGS="${LDFLAGS} -Wl,-Bsymbolic-functions"

# -Wl,-no-pie
#
#  This is the linker's -no-pie flag and is default behavior. Define it here in
#  case some builds try to override it.
#
LDFLAGS="${LDFLAGS} -Wl,-no-pie"

# -Wl,-O2
#
#  This flag makes LLD use zlib to compress the final code output. There are 2
#  useful levels: level 1 and level 2. Level 0 obviously disables size
#  optimization. Level 1 is fastest compression and level 2 is high compression
#  equal to zlib level 6. Use level 2 to keep compiled code small and memory
#  efficient, especially when using high level optimizations.
#
#  You can define levels higher than 2, but it won't make a difference and
#  according to the source code commentary, takes significantly longer.
#
LDFLAGS="${LDFLAGS} -Wl,-O2"

# -Wl,-z,now
#
#  This flag changes the default linker behavior from lazy to eager binding.
#  This makes the code resolve all symbols at load.
#
LDFLAGS="${LDFLAGS} -Wl,-z,now"

# -Wl,-z,relro
#
#  This flag is enabled by default. Define it here in case some builds try to
#  override it.
#
LDFLAGS="${LDFLAGS} -Wl,-z,relro"

# -Wl,--as-needed
#
#  This flag sets DT_NEEDED for shared libraries if used. If libraries aren't
#  needed during link-time, the linker skips them saving code size and
#  unnecessary executions.
#
LDFLAGS="${LDFLAGS} -Wl,--as-needed"

# -Wl,--gc-sections
#
#  This flag makes the linker collect garbage during link-time, removing unused
#  symbols that can bloat the code. This helps keep code size smaller and more
#  memory efficient.
#
LDFLAGS="${LDFLAGS} -Wl,--gc-sections"

# -Wl,--icf=all
#
#  This flag makes the linker fold identical code during link-time, which can
#  bloat the code. This helps keep code size smaller and memory efficient.
#  There are three levels: none, safe, and all. If all causes failures, try
#  safe, and then try disabling the flag.
#
LDFLAGS="${LDFLAGS} -Wl,--icf=all"

# -Wl,--lto-O3
#
#  This flag sets the linker optimization pipeline level during link-time.
#  There are 4 levels: level 0, level 1, level 2, and level 3. Level 3 is the
#  maximum level, you can't rice beyond it. This option adds more passes and
#  makes some passes more aggressive.
#
LDFLAGS="${LDFLAGS} -Wl,--lto-O3"

# -Wl,--lto-whole-program-visibility
#
#  This flag forces LLD to expose all code that was marked hidden while
#  compiling during link-time. With whole program visibility, Clang can make
#  more efficient optimizations during the link phase because it has full
#  access to the code.
#
LDFLAGS="${LDFLAGS} -Wl,--lto-whole-program-visibility"
