# C compiler flags. These flags are used while Clang compiles C code. They
# carry over to CXXFLAGS and will also be used while Clang compiles C++ code.

# basic C flags
#
#  These are our default C flags. CPU optimizations, optimization level, and
#  memory piping.
#
CFLAGS="-march=native -O3 -pipe"

# -fcf-protection=none
#
#  This flag is for code flow integrity protection. CFI is a set of features
#  which are designed to abort the program upon detecting certain forms of
#  undefined behavior that can potentially allow attackers to subvert the
#  programâ€™s control flow.
#
#  This causes a slight performance overhead and can increase code size, which
#  we don't want since we're already using -O3. Setting this to none disables
#  all code flow integrity protection.
#
CFLAGS="${CFLAGS} -fcf-protection=none"

# -fdata-sections
#
#  This flag places each data into its own section and allows the linker to
#  mark sections as not needed. Code marked as unnecessary data can be removed
#  with -Wl,--gc-sections which can drastically reduce code size.
#
CFLAGS="${CFLAGS} -fdata-sections"

# -fdirect-access-external-data
#
#  This flag uses direct access relocations instead of GOT to reference
#  external data symbols. This is the default behavior for static code, but
#  since Gentoo uses PIC, we want to bypass GOT/PLT as much as possible.
#
CFLAGS="${CFLAGS} -fdirect-access-external-data"

# -ffast-math
#
#  This flag breaks C standards in favor of ricing. It allows the compiler to
#  take math shortcuts at the expense of accuracy, allowing code to execute
#  less calculations resulting in faster execution. Disable it for packages
#  that require accurate math.
#
#  -Ofast implies -O3 -ffast-math, but you get more flexibility by using
#  -ffast-math since you can define it with any optimization level.
#
CFLAGS="${CFLAGS} -ffast-math"

# -fforce-emit-vtables
#
#  This flag emits more virtual tables to improve devirtualization.
#
CFLAGS="${CFLAGS} -fforce-emit-vtables"

# -ffp-contract=fast
#
#  Form fused floating-point operations. Clang's default is set to on for most
#  code, fast for CUDA code, and fast-honor-pragmas for HIP code. This changes
#  Clang's -ffp-contract behavior to fast which is the default behavior in GCC.
#
#  This option is turned on with -ffast-math, but having it always enabled will
#  allow it to be used when -ffast-math can't be used..
#
CFLAGS="${CFLAGS} -ffp-contract=fast"

# -ffunction-sections
#
#  This places each fuction into it's own section and allows the linker to mark
#  sections as not needed. Code marked as unnecessary functions can be removed
#  with -Wl,--gc-sections which can drastically reduce code size.
#
CFLAGS="${CFLAGS} -ffunction-sections"

# -flto
#
#  This flag makes Clang optimize code at link-time rather than compile time.
#  The benefit is the compiler can see everything at once and then make the
#  best optimizations for the program as a whole instead of what's best for
#  each piece individually. Theoretically you get smaller, more optimized
#  programs but that is not always the case and some programs end up slower or
#  incorrectly compiled with LTO.
#
#  There are two methods for LTO: full and thin. Thin is more memory efficient
#  and allows the LTO phase to run in parallel for faster compilation. The
#  downside is you sacrifice program visibility and flags like
#  -fno-semantic-interposition are more prone to failure with -flto=thin. Full
#  mode is slower since it isn't parallel. It also requires more memory but has
#  better visibility since code isn't being cut into pieces for parallel
#  threading. For that reason it works better with -fno-semantic-interposition
#  and you can only use -fvirtual-function-elimination with full mode. If you
#  can manage the extra memory required and don't mind a little slower
#  compilation, choose full for the extra visibility.
#
#  In order to take full advantage of devirtualization, it's recommended to use
#  link-time optimization.
#
CFLAGS="${CFLAGS} -flto"

# -fno-common
#
#  This flag specifies that variables without initializers won't have common
#  linkage. -fcommon implies a speed and size penalty, and is currently
#  deprecated since the default is -fno-common with both Clang and GCC. It's
#  a harmless flag to enable so it's defined here just in case it gets enabled
#  somewhere, somehow.
#
CFLAGS="${CFLAGS} -fno-common"

# -fno-PIE
#
#  This flag disables position-independent execution. PIE is similar to PIC,
#  but the generated position-independent code can be only linked into
#  executables.
#
#  Some packages might want to compile with -fpie/-fPIE/-pie which makes
#  attacks a little harder, but causes a performance overhead. This is the
#  compile time flag. Use it with the link time flag -no-pie for predictable
#  results.
#
CFLAGS="${CFLAGS} -fno-PIE"

# -fno-plt
#
#  This flag uses GOT indirection instead of PLT to make external function
#  calls. This leads to more efficient code by eliminating PLT stubs and
#  exposing GOT loads to optimizations.
#
CFLAGS="${CFLAGS} -fno-plt"

# -fno-sanitize=all
#
#  This flag is for various sanitizers. Sanitizers usually cause memory and CPU
#  overhead that we don't want. This turns any flags off in case any are turned
#  on by default. You can't turn all sanitizers on at once, but you can disable
#  them all at once with this mighty flag.
#
CFLAGS="${CFLAGS} -fno-sanitize=all"

# -fno-semantic-interposition
#
#  ELF allows interposing of symbols by the dynamic linker. This means that for
#  symbols exported from the DSO, the compiler cannot perform interprocedural
#  propagation, inlining and other optimizations in anticipation that the
#  function or variable in question may change. We don't want this because it
#  hurts performance.
#
CFLAGS="${CFLAGS} -fno-semantic-interposition"

# -fno-stack-protector
#
#  This flag is for stack smashing protection. This helps the compiler detect
#  stack buffer overflows. Like other hardening features, extra checks cause
#  extra overhead.
#
CFLAGS="${CFLAGS} -fno-stack-protector"

# -fstrict-vtable-pointers
#
#  This flag enables optimizations based on the strict rules for overwriting
#  polymorphic C++ and other object oriented languages.
#
CFLAGS="${CFLAGS} -fstrict-vtable-pointers"

# -fveclib=libmvec
#
#  This flag allows Clang to use the auto-vectorization features of glibc's
#  vector math library, libmvec. If you aren't using glibc, then remove the
#  flag.
#
CFLAGS="${CFLAGS} -fveclib=libmvec"

# -fvirtual-function-elimination
#
#  This flag removes dead virtual functions from vtables so that CGProfile
#  metadata gets cleaned up correctly. It can only be used with full LTO
#  because it needs to see every call to llvm.type.checked.load in the linkage
#  unit, which ThinLTO doesn't support currently.
#
#  This requires the flag -fwhole-program-vtables to function, which also
#  requires -flto. It doesn't work with -flto=thin, so if you're using thinLTO
#  you'll need to disable this flag.
#
CFLAGS="${CFLAGS} -fvirtual-function-elimination"

# -fwhole-program-vtables
#
#  This flag enables whole-program vtable optimizations for classes with hidden
#  LTO visibility. This flag requires -flto, and Portage will error during the
#  configure phase since Clang can't compile a test program if you have this
#  flag turned on without -flto.
#
CFLAGS="${CFLAGS} -fwhole-program-vtables"

# -Polly
#
#  This turns on LLVM's polyhedral optimization backend. This is similar to
#  using graphite in GCC. Currently disabled until Polly is in the Gentoo tree.
#
#CFLAGS="${CFLAGS} -mllvm -polly"

# -polly-vectorizer=stripmine
#
#  This flag turns on Polly's automatic vectorization feature.
#
#CFLAGS="${CFLAGS} -mllvm -polly-vectorizer=stripmine"

# maybe enable in the future
#CFLAGS="${CFLAGS} -mllvm -polly-omp-backend=LLVM"
#CFLAGS="${CFLAGS} -mllvm -polly-parallel"
