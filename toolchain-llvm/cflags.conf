# These are our default C flags. CPU optimizations, optimization level, and
# memory piping.
#
CFLAGS="-march=native -O3 -pipe"

# Disable code flow integrity protection. CFI is a set of features which are
# designed to abort the program upon detecting certain forms of undefined
# behavior that can potentially allow attackers to subvert the programâ€™s
# control flow. This causes a slight performance overhead and increases code
# size.
#
CFLAGS="${CFLAGS} -fcf-protection=none"

# Create sections for data and allow the linker to mark sections as not needed.
# Code marked as unnecessary data can be removed with Wl,--gc-sections which
# can drastically reduce code size.
#
CFLAGS="${CFLAGS} -fdata-sections"

# Use direct access relocations instead of GOT to reference external data
# symbols. This is similar behavior to static code. Gentoo compiles shared code
# by default so we want to bypass GOT/PLT as much as possible.
#
CFLAGS="${CFLAGS} -fdirect-access-external-data"

# Break C standards in favor of ricing. It allows the compiler to take math
# shortcuts at the expense of accuracy, allowing code to execute less
# calculations resulting in faster execution. Disable it for packages that
# require accurate math.
#
# -Ofast implies -O3 -ffast-math, but you get more flexibility by using
# -ffast-math since you can define it with any optimization level.
#
CFLAGS="${CFLAGS} -ffast-math"

# Emit more virtual tables to improve devirtualization.
#
CFLAGS="${CFLAGS} -fforce-emit-vtables"

# Form fused floating-point operations. Clang's default is set to on for most
# code, fast for CUDA code, and fast-honor-pragmas for HIP code. This changes
# Clang's -ffp-contract behavior to fast which is the default behavior in GCC.
#
# This option is turned on with -ffast-math, but having it always enabled will
# allow it to be used when -ffast-math can't be used..
#
CFLAGS="${CFLAGS} -ffp-contract=fast"

# Creates sections for fuctions and allow the linker to mark sections as not
# needed. Code marked as unnecessary functions can be removed with
# -Wl,--gc-sections which can drastically reduce code size.
#
CFLAGS="${CFLAGS} -ffunction-sections"

# Optimize code at link-time rather than compile time. The benefit is the
# compiler can see everything at once and then make the best optimizations for
# the whole program. Theoretically you get smaller, more optimized programs but
# that is not always the case and some programs end up slower or incorrectly
# compiled with LTO.
#
# There are two methods for LTO: full and thin. Thin is more memory efficient
# and allows the LTO phase to run in parallel for faster compilation. The
# downside is you sacrifice program visibility and flags like
# -fno-semantic-interposition are more prone to failure with -flto=thin. Full
# mode is slower since it isn't parallel. It also requires more memory but has
# better visibility since code isn't being cut into pieces for parallel
# threading. For that reason it works better with -fno-semantic-interposition
# and you can only use -fvirtual-function-elimination with full mode. If you
# can manage the extra memory required and don't mind a little slower
# compilation, choose full for the extra visibility.
#
# In order to take full advantage of devirtualization, it's recommended to use
# link-time optimization.
#
CFLAGS="${CFLAGS} -flto"

# Variables without initializers won't have common linkage. Common linkage
# implies a speed and size penalty, and is currently deprecated. It's harmless
# to enable so it's defined here just in case.
#
CFLAGS="${CFLAGS} -fno-common"

# Use GOT indirection instead of PLT to make external function calls. This
# leads to more efficient code by eliminating PLT stubs and exposing GOT loads
# to optimizations.
#
CFLAGS="${CFLAGS} -fno-plt"

# Sanitizers cause memory and CPU overhead that we don't want. This turns off
# any sanitizers in case any are turned on by default. You can't turn them all
# on at once, but you can disable them all at once with this mighty flag.
#
CFLAGS="${CFLAGS} -fno-sanitize=all"

# For shared code ELF allows interposing of symbols by the dynamic linker. This
# means that for symbols exported from the DSO, the compiler cannot perform
# interprocedural propagation, inlining and other optimizations. This returns
# some of the performance that PIC/PIE has stolen.
#
CFLAGS="${CFLAGS} -fno-semantic-interposition"

# Stack smashing protection helps the compiler detect stack buffer overflows.
# The extra checks cause extra overhead so off with their heads.
#
CFLAGS="${CFLAGS} -fno-stack-protector"

# Use the auto-vectorization features of glibc's vector math library, libmvec.
# If you aren't using glibc, then remove the flag.
#
CFLAGS="${CFLAGS} -fveclib=libmvec"

# Remove dead virtual functions from vtables so that CGProfile metadata gets
# cleaned up correctly. It can only be used with full LTO because it needs to
# see every call to llvm.type.checked.load in the linkage unit, which ThinLTO
# doesn't support currently.
#
# This requires -fwhole-program-vtables to function, which also requires -flto.
#
CFLAGS="${CFLAGS} -fvirtual-function-elimination"

# Enable whole-program vtable optimizations for classes with hidden LTO
# visibility. This flag requires -flto.
#
CFLAGS="${CFLAGS} -fwhole-program-vtables"
